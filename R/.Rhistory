}
}
# Plot length distribution
graphics.off()
pdf("/Users/davidsebastianfischer/phd/data/DPT_MST/figures/BranchLength.pdf")
plot(seq(1,length(lsLongestPathsDist)), unlist(lsLongestPathsDist))
dev.off()
plot(seq(1,length(lsLongestPathsDist)), unlist(lsLongestPathsDist))
scaBranches <- 3 #length(lsLongestPaths)
g <- ggplot(dif, aes(x=DC1, y=DC2)) +
geom_point(aes(colour = factor(cellstage))) +
scale_color_brewer(palette = "Spectral")
for(i in seq(1, scaBranches)){
# Get set of unique MST edges
x <- eigenvectors(dif)[,"DC1"]
y <- eigenvectors(dif)[,"DC2"]
vecCell1 <- lsLongestPaths[[i]][1:(length(lsLongestPaths[[i]])-1)]
vecCell2 <- lsLongestPaths[[i]][2:length(lsLongestPaths[[i]])]
dfEdgeBranch <- data.frame(x1=x[vecCell1], x2=x[vecCell2], y1=y[vecCell1], y2=y[vecCell2])
g <- g + geom_segment(data = dfEdgeBranch, aes(x = x1, y = y1, xend = x2, yend = y2),
show.legend=TRUE)
}
graphics.off()
pdf("/Users/davidsebastianfischer/phd/data/DPT_MST/figures/DPTBranches.pdf")
print(g)
dev.off()
print(g)
# for analysis though?
scaD <- 2 #dim(dif@eigenvectors)[2]
# Get dpt distance matrix
matT <- dif@eigenvectors[,1:scaD] %*% diag(dif@eigenvalues[1:scaD]) %*% t(dif@eigenvectors[,1:scaD])
matM <- solve(diag(dim(matT)[1]) - matT + dif@eigenvec0 %o% dif@eigenvec0) - diag(dim(matT)[1])
matDPT <- do.call(rbind, lapply(seq(1,dim(matM)[1]), function(i){
sapply(seq(1,dim(matM)[1]), function(j){
sqrt(sum((matM[i,]-matM[j,])^2))
})
}))
# Plot DPT
graphics.off()
g <- ggplot(dif, aes(x=DC1, y=DC2)) +
geom_point(aes(colour = factor(cellstage))) +
scale_color_brewer(palette = "Spectral")
# Compute MST
mstDPT <- mst(matDPT)
# Get set of unique MST edges
x <- eigenvectors(dif)[,"DC1"]
y <- eigenvectors(dif)[,"DC2"]
vecEdges <- which(mstDPT==1)
cell1 <- vecEdges %/% dim(eigenvectors(dif))[1] + 1
cell2 <- vecEdges %% dim(eigenvectors(dif))[1]
cell1[cell2==0] <- cell1[cell2==0] - 1
cell2[cell2==0] <- dim(eigenvectors(dif))[1]
# Validate cells are picked correctly:
# sapply(seq(1,length(cell1)), function(i) mstDPT[cell1[i],cell2[i]] )
dfCells <- cbind(cell1,cell2)
dfCells <- dfCells[apply(dfCells, 1, function(pair) pair[1] < pair[2] ),]
# Plot edges
dfEdge <- data.frame(x1=x[dfCells[,1]], x2=x[dfCells[,2]], y1=y[dfCells[,1]], y2=y[dfCells[,2]])
g <- g + geom_segment(data = dfEdge, aes(x = x1, y = y1, xend = x2, yend = y2),
show.legend=FALSE)
graphics.off()
pdf("/Users/davidsebastianfischer/phd/data/DPT_MST/figures/DestinyDataMST.pdf")
print(g)
dev.off()
print(g)
# Find branches
scaMinCells <- 5
lsBranches <- list()
boolLookForNext <- TRUE
vecLeaves <- which(apply(mstDPT, 1, function(i) sum(i)==1 ))
matMstWeights <- mstDPT*matDPT
#mstDPTTriangular <- mstDPT
#for(i in dim(mstDPTTriangular)[1]){
#  mstDPTTriangular[i,seq(i+1,dim(mstDPTTriangular)[2])] <- 0
#}
lsLongestPaths <- list()
lsLongestPathsDist <- list()
boolKeepDigging <- TRUE
matMstTempOverall <- mstDPT
while(boolKeepDigging){
# Start at leaves
scaMaxDist <- 0
vecMaxPath <- NA
for(leave in vecLeaves){
# Record distance to all other nodes
matMstTemp <- matMstTempOverall
indCurrentNode <- leave
indCurrentPath <- 1
lsPaths <- list()
lsPaths[[1]] <- indCurrentNode
lsDist <- list()
lsDist[[1]] <- 0
while(indCurrentPath <= length(lsPaths) | indCurrentPath==1){
indCurrentNode <- lsPaths[[indCurrentPath]][length(lsPaths[[indCurrentPath]])]
# Follow up one path
while(sum(matMstTemp[indCurrentNode,])>0){
if(sum(matMstTemp[indCurrentNode,])>1){
# Store branch to be completed later
lsPaths[[length(lsPaths)+1]] <- lsPaths[[indCurrentPath]]
lsDist[[length(lsPaths)+1]] <- lsDist[[indCurrentPath]]
}
# Chose new path
indNextNode <- match(1, matMstTemp[indCurrentNode,])
lsPaths[[indCurrentPath]] <- c(lsPaths[[indCurrentPath]], indNextNode)
lsDist[[indCurrentPath]] <- lsDist[[indCurrentPath]] + matDPT[indCurrentNode,indNextNode]
# Delete edge just walked
matMstTemp[indCurrentNode,indNextNode] <- 0
matMstTemp[indNextNode,indCurrentNode] <- 0
indCurrentNode <- indNextNode
}
indCurrentPath <- indCurrentPath + 1
}
# Find longest path
vecDist <- sapply(lsDist, sum)
scaMaxDistTemp <- max(vecDist)
indMaxDist <- match(scaMaxDistTemp, vecDist)
vecMaxPathTemp <- lsPaths[[indMaxDist]]
if(scaMaxDistTemp > scaMaxDist){
scaMaxDist <- scaMaxDistTemp
vecMaxPath <- vecMaxPathTemp
}
}
lsLongestPaths[[length(lsLongestPaths)+1]] <- vecMaxPath
lsLongestPathsDist[[length(lsLongestPathsDist)+1]] <- scaMaxDist
# Set walked paths to zero
for(i in seq(1,(length(vecMaxPath)-1))){
matMstTempOverall[vecMaxPath[i], vecMaxPath[i+1]] <- 0
matMstTempOverall[vecMaxPath[i+1], vecMaxPath[i]] <- 0
}
if(length(lsLongestPaths[[length(lsLongestPaths)]])<=scaMinCells){
boolKeepDigging <- FALSE
}
}
# Plot length distribution
graphics.off()
pdf("/Users/davidsebastianfischer/phd/data/DPT_MST/figures/BranchLength.pdf")
plot(seq(1,length(lsLongestPathsDist)), unlist(lsLongestPathsDist))
dev.off()
plot(seq(1,length(lsLongestPathsDist)), unlist(lsLongestPathsDist))
scaBranches <- 2 #length(lsLongestPaths)
g <- ggplot(dif, aes(x=DC1, y=DC2)) +
geom_point(aes(colour = factor(cellstage))) +
scale_color_brewer(palette = "Spectral")
for(i in seq(1, scaBranches)){
# Get set of unique MST edges
x <- eigenvectors(dif)[,"DC1"]
y <- eigenvectors(dif)[,"DC2"]
vecCell1 <- lsLongestPaths[[i]][1:(length(lsLongestPaths[[i]])-1)]
vecCell2 <- lsLongestPaths[[i]][2:length(lsLongestPaths[[i]])]
dfEdgeBranch <- data.frame(x1=x[vecCell1], x2=x[vecCell2], y1=y[vecCell1], y2=y[vecCell2])
g <- g + geom_segment(data = dfEdgeBranch, aes(x = x1, y = y1, xend = x2, yend = y2),
show.legend=TRUE)
}
graphics.off()
pdf("/Users/davidsebastianfischer/phd/data/DPT_MST/figures/DPTBranches.pdf")
print(g)
dev.off()
print(g)
rm(list=ls())
NCORES = 2
dirOutSimulation <- "/Users/davidsebastianfischer/MasterThesis/data/LineagePulse_simulations/simulate_local/simulation"
dirOutLineagePulse <- "/Users/davidsebastianfischer/MasterThesis/data/LineagePulse_simulations/simulate_local/LP_out"
dirValidationSimulationOut <- "/Users/davidsebastianfischer/MasterThesis/data/LineagePulse_simulations/simulate_local/validation"
lsDirs <- list(dirOutSimulation=dirOutSimulation,
dirOutLineagePulse=dirOutLineagePulse,
dirValidationSimulationOut=dirValidationSimulationOut,
NCORES=NCORES )
setwd(dirOutSimulation)
save(lsDirs,file=file.path("Simulation_lsDirs.RData"))
# Simulation parameters
PTmax <- 100
Ncells <- 100
Mumax <- 100
Nconst <- 20
NImp <- 20
scaSDImpulseAmplitude <- 1
# Simulate ZINB data
source("/Users/davidsebastianfischer/MasterThesis/code/LineagePulse/R/LineagePulse_main.R")
lsSimulatedDataSet <- simulateDataSet(scaNCells=Ncells,
scaNConst=Nconst,
scaNImp=NImp,
scaPTmax=PTmax,
scaMumax=Mumax,
scaSDImpulseAmplitude=scaSDImpulseAmplitude,
vecSizeFactorsExternal=NULL,
dirOutSimulation=dirOutSimulation)
matData <- lsSimulatedDataSet$matSampledCountsObserved
vecPT <- lsSimulatedDataSet$vecPT
# 4. Run LineagePulse
source("/Users/davidsebastianfischer/MasterThesis/code/LineagePulse/R/LineagePulse_main.R")
setwd(dirOutLineagePulse)
lsDEresults <- runLineagePulse(
matCounts=matData,
matPiConstPredictors=NULL,
vecPseudotime=vecPT,
scaKClusters=6,
scaSmallRun=NULL,
boolClusterInPseudotime = TRUE,
boolEstimateNoiseBasedOnH0=FALSE, #!
boolVecWindowsAsBFGS=FALSE,
boolCoEstDispMean=TRUE,
strMuModel="impulse",
strDispModel="constant",
scaWindowRadius=NULL,
boolPlotZINBfits=FALSE,
boolValidateZINBfit=TRUE,
scaMaxEstimationCycles=4,
scaNProc=3,#NCORES,
boolVerbose=TRUE,
boolSuperVerbose=TRUE )
setwd(dirOutLineagePulse)
load("LineagePulse_matCountsProc.RData")
load("LineagePulse_vecPseudotimeProc.RData")
load("LineagePulse_lsMuModelH0.RData")
load("LineagePulse_lsDispModelH0.RData")
load("LineagePulse_lsMuModelH1.RData")
load("LineagePulse_lsDispModelH1.RData")
load("LineagePulse_lsDropModel.RData")
#load("LineagePulse_matZH1.RData")
load("LineagePulse_dfDEAnalysis.RData")
vecDepth <- apply(matCountsProc, 2, function(cell){sum(cell, na.rm=TRUE)})
names(vecDepth) <- colnames(matCountsProc)
scaNCells5 <- min(scaNumCells,10)
print(paste0("# 5. Plot logistic dropout rate fit as function of mean",
" coloured by sequencing depth."))
# Define mu values at which logistic function is sampled
scaMaxMu <- 10^4
#vecMu=sapply(seq( 1, round(log(scaMaxMu)/log(2)) ), function(x) 2^x)
vecMu <- seq(1,scaMaxMu+1,by=scaMaxMu/100)
matDropoutSampled <- matrix(NA, nrow=length(vecMu), ncol=scaNCells5)
for(cell in seq(1,scaNCells5)){
matDropoutSampled[,cell] <- decompressDropoutRateByCell(vecDropModel=lsDropModel$matDropoutLinModel[cell,],
vecMu=vecMu,
matPiConstPredictors=lsDropModel$matPiConstPredictors )
}
colnames(matDropoutSampled) <- seq(1,scaNCells5)
dfDropoutSampledMolten <- melt(matDropoutSampled)
scaNCells5 <- min(scaNumCells,10)
scaNumCells = dim(matCountsProc)[2]
scaNumGenes = dim(matCountsProc)[1]
scaNCells5 <- min(scaNumCells,10)
print(paste0("# 5. Plot logistic dropout rate fit as function of mean",
" coloured by sequencing depth."))
# Define mu values at which logistic function is sampled
scaMaxMu <- 10^4
#vecMu=sapply(seq( 1, round(log(scaMaxMu)/log(2)) ), function(x) 2^x)
vecMu <- seq(1,scaMaxMu+1,by=scaMaxMu/100)
matDropoutSampled <- matrix(NA, nrow=length(vecMu), ncol=scaNCells5)
for(cell in seq(1,scaNCells5)){
matDropoutSampled[,cell] <- decompressDropoutRateByCell(vecDropModel=lsDropModel$matDropoutLinModel[cell,],
vecMu=vecMu,
matPiConstPredictors=lsDropModel$matPiConstPredictors )
}
colnames(matDropoutSampled) <- seq(1,scaNCells5)
dfDropoutSampledMolten <- melt(matDropoutSampled)
dfLines1 <- data.frame(
mu=rep(log(vecMu)/log(10), scaNCells5),
dropout=dfDropoutSampledMolten$value,
depth=vecDepth[match(dfDropoutSampledMolten$Var2,names(vecDepth))])
gLogisticDropoutvsMubyDepth <- ggplot(dfLines1, aes(x=mu, y=dropout, group=depth)) +
geom_line(aes(colour=depth)) +
scale_colour_gradient(low="red",high="green") +
labs(title="Logistic drop-out model versus sequencing depth by cell") +
xlab(paste0("log_10 mean parameter H1")) +
ylab(paste0("dropout rate")) +
#    xlim(c(-1,2)) +
theme(axis.text=element_text(size=14),
axis.title=element_text(size=14,face="bold"),
title=element_text(size=14,face="bold"),
legend.text=element_text(size=14))
print(gLogisticDropoutvsMubyDepth)
gLogisticDropoutvsMubyDepth
any(is.na(matDropoutSampled))
matDropoutSampled
dfLines1
head(lsDropModel$matDropoutLinMode)
colnames(matDropoutSampled) <- rownames(lsDropModel$matDropoutLinModel[seq(1,scaNCells5),]
dfDropoutSampledMolten <- melt(matDropoutSampled)
dfLines1 <- data.frame(
mu=rep(log(vecMu)/log(10), scaNCells5),
dropout=dfDropoutSampledMolten$value,
depth=vecDepth[match(dfDropoutSampledMolten$Var2,names(vecDepth))])
gLogisticDropoutvsMubyDepth <- ggplot(dfLines1, aes(x=mu, y=dropout, group=depth)) +
geom_line(aes(colour=depth)) +
scale_colour_gradient(low="red",high="green") +
labs(title="Logistic drop-out model versus sequencing depth by cell") +
xlab(paste0("log_10 mean parameter H1")) +
ylab(paste0("dropout rate")) +
#    xlim(c(-1,2)) +
theme(axis.text=element_text(size=14),
axis.title=element_text(size=14,face="bold"),
title=element_text(size=14,face="bold"),
legend.text=element_text(size=14))
n
print(gLogisticDropoutvsMubyDepth)
dfLines1
head(dfDropoutSampledMolten)
vecMu <- seq(1,scaMaxMu+1,by=scaMaxMu/100)
matDropoutSampled <- matrix(NA, nrow=length(vecMu), ncol=scaNCells5)
for(cell in seq(1,scaNCells5)){
matDropoutSampled[,cell] <- decompressDropoutRateByCell(vecDropModel=lsDropModel$matDropoutLinModel[cell,],
vecMu=vecMu,
matPiConstPredictors=lsDropModel$matPiConstPredictors )
}
colnames(matDropoutSampled) <- rownames(lsDropModel$matDropoutLinModel[seq(1,scaNCells5),])
dfDropoutSampledMolten <- melt(matDropoutSampled)
dfLines1 <- data.frame(
mu=rep(log(vecMu)/log(10), scaNCells5),
dropout=dfDropoutSampledMolten$value,
depth=vecDepth[match(dfDropoutSampledMolten$Var2,names(vecDepth))])
head(dfLines1)
scaNCells5 <- min(scaNumCells,10)
print(paste0("# 5. Plot logistic dropout rate fit as function of mean",
" coloured by sequencing depth."))
# Define mu values at which logistic function is sampled
scaMaxMu <- 10^4
#vecMu=sapply(seq( 1, round(log(scaMaxMu)/log(2)) ), function(x) 2^x)
vecMu <- seq(1,scaMaxMu+1,by=scaMaxMu/100)
matDropoutSampled <- matrix(NA, nrow=length(vecMu), ncol=scaNCells5)
for(cell in seq(1,scaNCells5)){
matDropoutSampled[,cell] <- decompressDropoutRateByCell(vecDropModel=lsDropModel$matDropoutLinModel[cell,],
vecMu=vecMu,
matPiConstPredictors=lsDropModel$matPiConstPredictors )
}
colnames(matDropoutSampled) <- rownames(lsDropModel$matDropoutLinModel[seq(1,scaNCells5),])
dfDropoutSampledMolten <- melt(matDropoutSampled)
dfLines1 <- data.frame(
mu=rep(log(vecMu)/log(10), scaNCells5),
dropout=dfDropoutSampledMolten$value,
depth=vecDepth[match(dfDropoutSampledMolten$Var2,names(vecDepth))])
gLogisticDropoutvsMubyDepth <- ggplot(dfLines1, aes(x=mu, y=dropout, group=depth)) +
geom_line(aes(colour=depth)) +
scale_colour_gradient(low="red",high="green") +
labs(title="Logistic drop-out model versus sequencing depth by cell") +
xlab(paste0("log_10 mean parameter H1")) +
ylab(paste0("dropout rate")) +
#    xlim(c(-1,2)) +
theme(axis.text=element_text(size=14),
axis.title=element_text(size=14,face="bold"),
title=element_text(size=14,face="bold"),
legend.text=element_text(size=14))
print(gLogisticDropoutvsMubyDepth)
gLogisticDropoutvsMubyDepth
gLogisticDropoutvsMubyDepth <- ggplot(dfLines1, aes(x=mu, y=dropout, group=depth)) +
geom_line(aes(colour=depth)) +
scale_colour_gradient(low="red",high="green") +
labs(title="Logistic drop-out model versus sequencing depth by cell") +
xlab(paste0("log_10 mean parameter H1")) +
ylab(paste0("dropout rate")) +
#    xlim(c(-1,2)) +
theme(axis.text=element_text(size=14),
axis.title=element_text(size=14,face="bold"),
title=element_text(size=14,face="bold"),
legend.text=element_text(size=14))
print(gLogisticDropoutvsMubyDepth)
graphics.off()
print(gLogisticDropoutvsMubyDepth)
scaNCells5 <- min(scaNumCells,1000)
print(paste0("# 5. Plot logistic dropout rate fit as function of mean",
" coloured by sequencing depth."))
# Define mu values at which logistic function is sampled
scaMaxMu <- 10^4
#vecMu=sapply(seq( 1, round(log(scaMaxMu)/log(2)) ), function(x) 2^x)
vecMu <- seq(1,scaMaxMu+1,by=scaMaxMu/100)
matDropoutSampled <- matrix(NA, nrow=length(vecMu), ncol=scaNCells5)
for(cell in seq(1,scaNCells5)){
matDropoutSampled[,cell] <- decompressDropoutRateByCell(vecDropModel=lsDropModel$matDropoutLinModel[cell,],
vecMu=vecMu,
matPiConstPredictors=lsDropModel$matPiConstPredictors )
}
colnames(matDropoutSampled) <- rownames(lsDropModel$matDropoutLinModel[seq(1,scaNCells5),])
dfDropoutSampledMolten <- melt(matDropoutSampled)
dfLines1 <- data.frame(
mu=rep(log(vecMu)/log(10), scaNCells5),
dropout=dfDropoutSampledMolten$value,
depth=vecDepth[match(dfDropoutSampledMolten$Var2,names(vecDepth))])
gLogisticDropoutvsMubyDepth <- ggplot(dfLines1, aes(x=mu, y=dropout, group=depth)) +
geom_line(aes(colour=depth)) +
scale_colour_gradient(low="red",high="green") +
labs(title="Logistic drop-out model versus sequencing depth by cell") +
xlab(paste0("log_10 mean parameter H1")) +
ylab(paste0("dropout rate")) +
#    xlim(c(-1,2)) +
theme(axis.text=element_text(size=14),
axis.title=element_text(size=14,face="bold"),
title=element_text(size=14,face="bold"),
legend.text=element_text(size=14))
print(gLogisticDropoutvsMubyDepth)
scaNCells5 <- min(scaNumCells,1000)
print(paste0("# 5. Plot logistic dropout rate fit as function of mean",
" coloured by sequencing depth."))
# Define mu values at which logistic function is sampled
scaMaxMu <- 10^4
vecMu=sapply(seq( 1, round(log(scaMaxMu)/log(2)), by=0.2 ), function(x) 2^x)
matDropoutSampled <- matrix(NA, nrow=length(vecMu), ncol=scaNCells5)
for(cell in seq(1,scaNCells5)){
matDropoutSampled[,cell] <- decompressDropoutRateByCell(vecDropModel=lsDropModel$matDropoutLinModel[cell,],
vecMu=vecMu,
matPiConstPredictors=lsDropModel$matPiConstPredictors )
}
colnames(matDropoutSampled) <- rownames(lsDropModel$matDropoutLinModel[seq(1,scaNCells5),])
head(matDropoutSampled)
which(matDropoutSampled[10,]>matDropoutSampled[9,])
which(matDropoutSampled[11,]>matDropoutSampled[9,])
head(dfLines1)
vecDepth[match(dfDropoutSampledMolten$Var2,names(vecDepth))]
dfDropoutSampledMolten$Var2
head(dfDropoutSampledMolten)
unique(vecDepth)
vecDepth
duplicated(vecDepth)
vecDepthUnique <- vecDepth
while(any(duplicated(vecDepthUnique))){
vecDepthUnique[duplicated(vecDepthUnique)] <- vecDepthUnique[duplicated(vecDepthUnique)]+0.001
}
vecDepthUnique
dfLines1 <- data.frame(
mu=rep(log(vecMu)/log(10), scaNCells5),
dropout=dfDropoutSampledMolten$value,
depth=vecDepth[match(dfDropoutSampledMolten$Var2,names(vecDepthUnique))])
gLogisticDropoutvsMubyDepth <- ggplot(dfLines1, aes(x=mu, y=dropout, group=depth)) +
geom_line(aes(colour=depth)) +
scale_colour_gradient(low="red",high="green") +
labs(title="Logistic drop-out model versus sequencing depth by cell") +
xlab(paste0("log_10 mean parameter H1")) +
ylab(paste0("dropout rate")) +
#    xlim(c(-1,2)) +
theme(axis.text=element_text(size=14),
axis.title=element_text(size=14,face="bold"),
title=element_text(size=14,face="bold"),
legend.text=element_text(size=14))
print(gLogisticDropoutvsMubyDepth)
dfLines1
dfLines1 <- data.frame(
mu=rep(log(vecMu)/log(10), scaNCells5),
dropout=dfDropoutSampledMolten$value,
depth=vecDepthUnique[match(dfDropoutSampledMolten$Var2,names(vecDepthUnique))])
gLogisticDropoutvsMubyDepth <- ggplot(dfLines1, aes(x=mu, y=dropout, group=depth)) +
geom_line(aes(colour=depth)) +
scale_colour_gradient(low="red",high="green") +
labs(title="Logistic drop-out model versus sequencing depth by cell") +
xlab(paste0("log_10 mean parameter H1")) +
ylab(paste0("dropout rate")) +
#    xlim(c(-1,2)) +
theme(axis.text=element_text(size=14),
axis.title=element_text(size=14,face="bold"),
title=element_text(size=14,face="bold"),
legend.text=element_text(size=14))
dev.off()
print(gLogisticDropoutvsMubyDepth)
dfLines1
dfLines1
vecDepthUnique
dfLines1 <- data.frame(
mu=rep(log(vecMu)/log(10), scaNCells5),
dropout=dfDropoutSampledMolten$value,
depth=vecDepthUnique[match(dfDropoutSampledMolten$Var2,names(vecDepthUnique))])
length(match(dfDropoutSampledMolten$Var2,names(vecDepthUnique)))
dim(dfDropoutSampledMolten)
length(rep(log(vecMu)/log(10), scaNCells5))
length(log(vecMu)/log(10))
scaNCells5
scaNumCells
dim(matDropoutSampled)
scaMaxMu <- 10^4
vecMu=sapply(seq( 1, round(log(scaMaxMu)/log(2)), by=0.2 ), function(x) 2^x)
matDropoutSampled <- matrix(NA, nrow=length(vecMu), ncol=scaNCells5)
for(cell in seq(1,scaNCells5)){
matDropoutSampled[,cell] <- decompressDropoutRateByCell(vecDropModel=lsDropModel$matDropoutLinModel[cell,],
vecMu=vecMu,
matPiConstPredictors=lsDropModel$matPiConstPredictors )
}
colnames(matDropoutSampled) <- rownames(lsDropModel$matDropoutLinModel[seq(1,scaNCells5),])
dfDropoutSampledMolten <- melt(matDropoutSampled)
# Reset non-uniue depth values
vecDepthUnique <- vecDepth
while(any(duplicated(vecDepthUnique))){
vecDepthUnique[duplicated(vecDepthUnique)] <- vecDepthUnique[duplicated(vecDepthUnique)]+0.001
}
dfLines1 <- data.frame(
mu=rep(log(vecMu)/log(10), scaNCells5),
dropout=dfDropoutSampledMolten$value,
depth=vecDepthUnique[match(dfDropoutSampledMolten$Var2,names(vecDepthUnique))])
ggplot(dfLines1, aes(x=mu, y=dropout, group=depth)) +
geom_line(aes(colour=depth)) +
scale_colour_gradient(low="red",high="green") +
labs(title="Logistic drop-out model versus sequencing depth by cell") +
xlab(paste0("log_10 mean parameter H1")) +
ylab(paste0("dropout rate")) +
#    xlim(c(-1,2)) +
theme(axis.text=element_text(size=14),
axis.title=element_text(size=14,face="bold"),
title=element_text(size=14,face="bold"),
legend.text=element_text(size=14))
dfLines1 <- data.frame(
mu=rep(log(vecMu)/log(10), scaNCells5),
dropout=dfDropoutSampledMolten$value,
log_depth=log(vecDepthUnique[match(dfDropoutSampledMolten$Var2,names(vecDepthUnique))]))
ggplot(dfLines1, aes(x=mu, y=dropout, group=log_depth)) +
geom_line(aes(colour=log_depth)) +
scale_colour_gradient(low="red",high="green") +
labs(title="Logistic drop-out model versus sequencing depth by cell") +
xlab(paste0("log_10 mean parameter H1")) +
ylab(paste0("dropout rate")) +
#    xlim(c(-1,2)) +
theme(axis.text=element_text(size=14),
axis.title=element_text(size=14,face="bold"),
title=element_text(size=14,face="bold"),
legend.text=element_text(size=14))
source("/Users/davidsebastianfischer/MasterThesis/code/LineagePulse/R/LineagePulse_main.R")
validateOutput(dirOutLineagePulse=dirOutLineagePulse,
dirOutValidation=dirOutLineagePulse)
