% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/main_LineagePulse.R
\name{runLineagePulse}
\alias{runLineagePulse}
\alias{LineagePulse}
\alias{wrapper,}
\alias{main}
\alias{function}
\title{LineagePulse wrapper: Differential expression analysis in pseudotime}
\usage{
runLineagePulse(matCounts, dfAnnotation, vecConfoundersMu = NULL,
  vecConfoundersDisp = NULL, strMuModel = "impulse",
  strDispModelFull = "constant", strDispModelRed = "constant",
  strDropModel = "logistic_ofMu", strDropFitGroup = "PerCell",
  scaDFSplinesMu = 3, scaDFSplinesDisp = 3, matPiConstPredictors = NULL,
  vecNormConstExternal = NULL, boolEstimateNoiseBasedOnH0 = FALSE,
  scaMaxEstimationCycles = 20, scaNProc = 1, boolVerbose = TRUE,
  boolSuperVerbose = FALSE)
}
\arguments{
\item{matCounts:}{(matrix genes x cells)
Count data of all cells, unobserved entries are NA.}

\item{dfAnnotation:}{(data frame cells x meta characteristics)
Annotation table which contains meta data on cells.
May contain the following columns
cell: Cell IDs.
pseudotime: Pseudotemporal coordinates of cells.
Confounder1: Batch labels of cells with respect 
to first confounder. Name is arbitrary: Could
for example be "patient" with batch labels
patientA, patientB, patientC.
Confounder2: As Confounder1 for another confounding
variable.
... ConfounderX.
population: Fixed population assignments (for
strMuModel="MM"). Cells not assigned have to be NA.
clusters: External clustering results assigning each cell
to one cluster ID. Used if strMuModel=="clusters" and this
column is given, otherwise clustering is internally generated.
rownames: Must be IDs from column cell.
Remaining entries in table are ignored.}

\item{vecConfounders:}{Confounders to correct for in mu batch
correction model, must be subset of column names of
dfAnnotation which describe condounding variables.}

\item{vecConfoundersDisp:}{Confounders to correct for in dispersion batch
correction model, must be subset of column names of
dfAnnotation which describe condounding variables.}

\item{strMuModel:}{(str) {"constant", "cluster", "MM",
"windows","impulse"}
[Default "impulse"] Model according to which the mean
parameter is fit to each gene as a function of 
pseudotime in the alternative model (H1).}

\item{strDispModel:}{(str) {"constant"}
[Default "constant"] Model according to which dispersion
parameter is fit to each gene as a function of 
pseudotime in the alternative model (H1).}

\item{matPiConstPredictors:}{(numeric matrix genes x number of constant
gene-wise drop-out predictors) Predictors for logistic drop-out 
fit other than offset and mean parameter (i.e. parameters which
are constant for all observations in a gene and externally supplied.)
Is null if no constant predictors are supplied}

\item{vecNormConstExternal:}{(numeric vector number of cells) 
Model scaling factors, one per cell. These factors will linearly 
scale the mean model for evaluation of the loglikelihood. 
Must be named according to the column names of matCounts.}

\item{scaKCluster:}{(integer) [Default NULL] Forces number of centroids
in K-means to be K: setting this to an integer (not NULL) skips model
selection in clusterting.}

\item{boolEstimateNoiseBasedOnH0:}{(bool) [Default: FALSE]
Whether to co-estimate logistic drop-out model with the 
constant null model or with the alternative model. The
co-estimation with the noise model typically extends the
run-time of this model-estimation step strongly. While
the drop-out model is more accurate if estimated based on
a more realistic model expression model (the alternative
model), a trade-off for speed over accuracy can be taken
and the dropout model can be chosen to be estimated based
on the constant null expression model (set to TRUE).}

\item{scaMaxEstimationCycles:}{(integer) [Default 20] Maximum number 
of estimation cycles performed in fitZINB(). One cycle
contain one estimation of of each parameter of the 
zero-inflated negative binomial model as coordinate ascent.}

\item{scaNProc:}{(scalar) [Default 1] Number of processes for 
parallelisation.}

\item{verbose:}{(bool) Whether to follow convergence of the 
iterative parameter estimation with one report per cycle.}

\item{boolSuperVerbose:}{(bool) Whether to follow convergence of the 
iterative parameter estimation in high detail with local 
convergence flags and step-by-step loglikelihood computation.}
}
\value{
dfDEAnalysis: (data frame genes x reported variables) 
   Summary of differential expression analysis, sorted by adj.p:
   {Gene: gene ID,
   p: raw p-value, 
   adj.p: BH corrected p-value, 
   loglik_full: loglikelihood of alternative model H1,
   loglik_red: loglikelihood of null model H0,
   deviance: loglikelihood ratio test statistic (the deviance),
   mean_H0: inferred gene-wise mean parameter (constant null model),
   dispersion_H0: inferred gene-wise dispersion parameter (constant null model)}
}
\description{
This function performs all steps of longitudinal differential
expression analysis in pseudotime for you.
}
\details{
This function is the wrapper function for the LineagePulse algorithm
which performs differential expression analysis in pseudotime. 
Note that LineagePulse has many input parameters but
only few will be relevant for you and you will be able to leave the 
remaining ones as their defaults. Read up on specific input parameters
in the input parameter annotation of this function or follow this short
guide:

MINIMAL INPUT
1. Supply data: Count data (matCounts) and pseudotime coordinates
of the cells (vecPseudotime). You may decide to also provide cell-wise
normalisation factors (such as factors accounting for sequencing depth)
(vecNormConstExternal).
2. Supply cell meta data: Data frame (dfAnnotation) which contains
all cell ids (the colnames of matCounts) in a column "cell",
and cell-wise pseudotime coordinates (scalar) in a a column "pseudpotime".
Rownames must be the ids in column "cell".
3. Chose the model constraining mean (strMuModel) and dispersion 
parameters (strDispModel) for each gene. If you run clusters,
you may decide to force the number of clusters (scaKCluster)
rather than using internal model selection or use clusters
based on true time (time of sampling) (boolClusterInPseudotime).

ADDITIONAL FACULTATIVE SETTINGS
5. Supply gene-specific drop-out predictors if wanted 
(matPiConstPredictors).
6. Set optimisation parameters (boolEstimateNoiseBasedOnH0,
scaMaxEstimationCycles).
7. Chose the number of processes you want to use (scaNProc), LineagePulse
is parallelised on all computation intensive steps. Note that
the current parallelisation scheme runs on Unix (MacOS) and Linux but
not on windows. Adjust the code section within this wrapper to
parallelise on windows.
8. Set the level of detail with which you want to follow
progress through text printed on the console during a run
(verbose, boolSuperVerbose).

Finally, after running LineagePulse, you may continue to work
on your data set by:
A) Regenerating observation-wise parameters,
such as the mean parameter matrix which represents the hidden
expression states, with the functions in srcLineagePulse_decompressParameters.R.
B) You can also compute the observation-wise probability of 
dropout with calcPostDrop.
C) You can have a closer look at the global expression
trajecotries of the genes with sortGeneTrajectories.
D) You can look at gene-wise model fits with plotGene().
E) If you use strMuModel=="clusters", you can plot the
observed density of cells across pseudotime and the cluster 
boundaries in this 1D space with plotPseudotimeClustering.
}
\author{
David Sebastian Fischer
}
